<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Scroll Effect - Three Background Cards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background-color: #F2F2F2;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }

        /* Контейнер для скролла с snap */
        .scroll-container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory; /* Обязательный snap */
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        /* Snap точки */
        .snap-point {
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
        }
        
        /* Отключаем snap для всех snap-point когда позиция <= 88px */
        .scroll-container.no-snap-cards .snap-point {
            scroll-snap-align: none !important;
            scroll-snap-stop: normal !important;
        }

        /* Навигационное меню */
        .navigation {
            position: sticky;
            top: -56px;
            height: 56px;
            z-index: 100;
            width: 100%;
            background-color: #F2F2F2;
            border-radius: 16px 16px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }

        .navigation-phone {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .navigation-phone-number {
            font-size: 16px;
            font-weight: 500;
            color: #000;
        }

        .navigation-phone-dropdown {
            width: 12px;
            height: 12px;
            color: #666;
            cursor: pointer;
        }

        .navigation-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF6B9D, #9B59B6);
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .navigation-avatar-inner {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .navigation-avatar-icon {
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            position: relative;
        }

        .navigation-avatar-icon::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 50% 30%, #000 2px, transparent 2px),
                radial-gradient(circle at 50% 50%, #000 2px, transparent 2px),
                radial-gradient(circle at 50% 70%, #000 2px, transparent 2px);
            background-size: 100% 33.33%;
            background-repeat: no-repeat;
        }

        /* Пустота сверху - скрытая область */
        .empty-space {
            height: 50vh;
            display: flex;
            flex-direction: column;
            position: relative;
            transform: translateY(56px);
        }
        
        .empty-space-content {
            margin-top: auto;
            padding-bottom: 20px;
            text-align: center;
        }


        .layout-container {
            background-color: #F2F2F2;
            max-width: 370px;
            margin: 0 auto;
            width: 100%;
            padding: 0;
            position: relative;
        }

        @media (max-width: 400px) {
            .layout-container {
                padding: 0 16px;
            }
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            margin: 10px 0;
            position: relative;
            min-height: 370px;
        }


        .card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .card p {
            color: #666;
            line-height: 1.6;
        }

        #animationCanvas {
            position: absolute;
            left: 50%;
            transform: translateX(-50%) translateY(-14.5%) scale(0.4);
            top: 0;
            background: transparent;
            border: none;
            z-index: 10;
        }

        .card-container {
            position: relative;
            min-height: 300px;
            padding-top: 150px; /* Место для canvas */
        }

        .background-section {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0;
            display: flex;
            align-items: top;
            justify-content: center;
            overflow: hidden;
        }

        .background-section-wrapper {
            margin-top: 100px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 20px;
            height: 300px;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-snap-type: x mandatory;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scroll-padding: 0 50%;
        }

        .background-section video {
            display: none; /* Скрываем оригинальное видео */
        }

        .background-section canvas {
            width: 300px;
            height: 300px;
            object-fit: contain;
            object-position: center;
            opacity: 1;
            flex: 0 0 auto;
            scroll-snap-align: center;
            scroll-snap-stop: always;
        }

        /* Контейнер для карточек с отступами */
        .cards-wrapper {
            padding-top: 0;
        }
        
        /* Убираем margin-top у первой карточки, так как отступ уже в snap-point */
        .layout-container > .card:first-of-type {
            margin-top: 0;
        }

        .debug-info {
            position: fixed;
            left: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

    </style>
</head>
<body>
    <div class="background-section">
        <div class="background-section-wrapper">
            <!-- Левая карточка -->
            <video id="backgroundVideoLeft" src="3221556df51311f0a9f6065170103629.mp4" autoplay loop muted playsinline></video>
            <canvas id="backgroundCanvasLeft"></canvas>
            
            <!-- Центральная карточка -->
            <video id="backgroundVideo" src="6cccfa21f50c11f0b1b012d53b0fb308.mp4" autoplay loop muted playsinline></video>
            <canvas id="backgroundCanvas"></canvas>
            
            <!-- Правая карточка -->
            <video id="backgroundVideoRight" src="63272c13f51311f0b6a7d69cb624da98.mp4" autoplay loop muted playsinline></video>
            <canvas id="backgroundCanvasRight"></canvas>
        </div>
    </div>
    
    <div class="scroll-container" id="scrollContainer">
        <!-- Пустота сверху - скрытая область, которая появляется при скролле вверх -->
        <div class="snap-point empty-space" id="emptySpace">
            <!-- Навигационное меню внутри empty-space -->
            <div class="navigation">
                <div class="navigation-phone">
                    <span class="navigation-phone-number">+7 (929) 747-78-70</span>
                    <svg class="navigation-phone-dropdown" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div class="navigation-avatar">
                    <div class="navigation-avatar-inner">
                        <div class="navigation-avatar-icon"></div>
                    </div>
                </div>
            </div>
            <div class="empty-space-content">
                
            </div>
        </div>
        
        <!-- Snap точка для нормального состояния - первая карточка на 32px + 56px (навигация) = 88px -->
        <div class="snap-point snap-point-normal" style="height: 88px;"></div>
        
        <!-- Контейнер с карточками -->
        <div class="cards-wrapper">
            <div class="layout-container">
                <div class="card" id="firstCard">
                    <div class="card-container">
                        <canvas id="animationCanvas"></canvas>
                    </div>
                    </div>

                <div class="card" id="secondCard">
                    </div>

                <div class="card">
                     </div>

                <div class="card">
                    </div>
            </div>
        </div>
        
        <!-- Snap точка для позиционирования второй карточки на 450px -->
        <div class="snap-point snap-point-second" style="height: calc(450px - 16px - 370px - 16px);"></div>
    </div>

    <div class="debug-info">
        <span id="scrollYDebug">scrollY: 0px</span>
        <span id="cardTopDebug">Card top: 0px</span>
        <span id="snapPointDebug">Snap point: -</span>
        <span id="scrollDirectionDebug">Scroll direction: -</span>
        <span id="currentFrameDebug">Current frame: 0</span>
        <span id="animationDirectionDebug">Animation direction: -</span>
    </div>

    <script>
        const scrollContainer = document.getElementById('scrollContainer');
        const scrollYDebug = document.getElementById('scrollYDebug');
        const cardTopDebug = document.getElementById('cardTopDebug');
        const snapPointDebug = document.getElementById('snapPointDebug');
        const scrollDirectionDebug = document.getElementById('scrollDirectionDebug');
        const currentFrameDebug = document.getElementById('currentFrameDebug');
        const animationDirectionDebug = document.getElementById('animationDirectionDebug');
        const firstCard = document.getElementById('firstCard');
        const emptySpace = document.getElementById('emptySpace');
        const backgroundVideo = document.getElementById('backgroundVideo');
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const backgroundCtx = backgroundCanvas ? backgroundCanvas.getContext('2d', { alpha: true }) : null;
        
        const backgroundVideoLeft = document.getElementById('backgroundVideoLeft');
        const backgroundCanvasLeft = document.getElementById('backgroundCanvasLeft');
        const backgroundCtxLeft = backgroundCanvasLeft ? backgroundCanvasLeft.getContext('2d', { alpha: true }) : null;
        
        const backgroundVideoRight = document.getElementById('backgroundVideoRight');
        const backgroundCanvasRight = document.getElementById('backgroundCanvasRight');
        const backgroundCtxRight = backgroundCanvasRight ? backgroundCanvasRight.getContext('2d', { alpha: true }) : null;
        
        const backgroundWrapper = document.querySelector('.background-section-wrapper');
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        // Параметры спрайта
        let spriteSheet = null;
        let frameWidth = 0;
        let frameHeight = 0;
        let totalFramesCount = 0;
        let videoFPS = 30;

        // Позиции для управления анимацией (как в scroll-animation.html)
        const CARD_POSITION_FIRST_FRAME = 80;   // При этой позиции или меньше - первый кадр (0)
        const CARD_POSITION_LAST_FRAME = 200;  // При этой позиции или больше - последний кадр

        // Состояние анимации
        let currentFrame = 0;
        let targetFrame = 0;
        let isAnimating = false;
        let lastFrameTime = 0;
        let animationId = null;
        let lastScrollY = 0;
        let scrollSpeed = 0;
        let lastScrollTime = Date.now();
        let isScrollingDown = false;
        const MAX_FRAME_DOWN = 28; // Максимальный кадр при скролле вверх
        let isSlidingDown = false; // Флаг для анимации смещения вниз
        let slideStartTime = 0;
        const SLIDE_DURATION = 700; // 0.7 секунды для смещения вниз
        
        // Эффект time echo - история предыдущих кадров
        const echoHistory = [];
        const ECHO_DURATION = 0.5;
        const ECHO_FADE_STEPS = 5;

        // Цвета для прозрачности
        const transparentColors = [
            { r: 235, g: 233, b: 231 }, // #EBE9E7
            { r: 255, g: 255, b: 255 }  // #FFF
        ];
        const threshold = 50;

        // Функция для проверки, является ли цвет "прозрачным"
        function shouldBeTransparent(r, g, b) {
            return transparentColors.some(color => {
                return Math.abs(r - color.r) <= threshold &&
                       Math.abs(g - color.g) <= threshold &&
                       Math.abs(b - color.b) <= threshold;
            });
        }

        // Функция для обработки кадра и создания прозрачности
        function processFrameData(imageData) {
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                if (shouldBeTransparent(r, g, b)) {
                    data[i + 3] = 0; // alpha
                }
            }
            
            return imageData;
        }

        // Функция для получения обработанного изображения кадра
        function getProcessedFrameImage(frameIndex) {
            if (!spriteSheet || frameIndex < 0 || frameIndex >= totalFramesCount) {
                return null;
            }
            
            const sourceX = frameIndex * frameWidth;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = frameWidth;
            tempCanvas.height = frameHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(
                spriteSheet,
                sourceX, 0, frameWidth, frameHeight,
                0, 0, frameWidth, frameHeight
            );
            
            const imageData = tempCtx.getImageData(0, 0, frameWidth, frameHeight);
            return processFrameData(imageData);
        }

        // Функция для отрисовки кадра с эффектом time echo
        function drawFrame(frameIndex, offsetY = 0) {
            if (!spriteSheet) {
                return;
            }
            
            if (frameIndex < 0 || frameIndex >= totalFramesCount) {
                return;
            }
            
            const now = performance.now();
            
            // Очищаем canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Удаляем старые кадры из истории (старше ECHO_DURATION)
            const cutoffTime = now - (ECHO_DURATION * 1000);
            while (echoHistory.length > 0 && echoHistory[0].timestamp < cutoffTime) {
                echoHistory.shift();
            }
            
            // Отрисовываем предыдущие кадры с уменьшающейся прозрачностью (от старых к новым)
            // Применяем смещение напрямую к координатам, так как putImageData не учитывает трансформации
            for (let i = 0; i < echoHistory.length; i++) {
                const echo = echoHistory[i];
                const age = (now - echo.timestamp) / 1000;
                const fadeProgress = age / ECHO_DURATION;
                const alpha = 1 - fadeProgress;
                
                if (alpha > 0 && echo.imageData) {
                    const fadedData = new ImageData(
                        new Uint8ClampedArray(echo.imageData.data),
                        echo.imageData.width,
                        echo.imageData.height
                    );
                    
                    for (let j = 3; j < fadedData.data.length; j += 4) {
                        fadedData.data[j] = Math.floor(fadedData.data[j] * alpha);
                    }
                    
                    // Применяем смещение напрямую к координатам отрисовки
                    ctx.putImageData(fadedData, 0, offsetY);
                }
            }
            
            // Получаем текущий кадр
            const currentImageData = getProcessedFrameImage(frameIndex);
            if (currentImageData) {
                // Применяем смещение напрямую к координатам отрисовки
                ctx.putImageData(currentImageData, 0, offsetY);
                
                const imageDataCopy = new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                );
                echoHistory.push({
                    frameIndex: frameIndex,
                    timestamp: now,
                    imageData: imageDataCopy
                });
            }
            
            // Если идет смещение вниз - рисуем серый прямоугольник на переднем плане
            if (offsetY > 0) {
                ctx.fillStyle = '#ffffff'; // Серый цвет
                const rectX = 0; // От левого края
                const rectY = canvas.height / 2 + 31; // От середины canvas + 31px вниз (7 + 24)
                const rectWidth = canvas.width; // До правого края
                const rectHeight = canvas.height / 2 - 31; // До нижнего края (уменьшаем высоту на 31px)
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
            }
        }

        // Загрузка спрайта
        async function loadSprite(spritePath = 'sprite.png', metadataPath = 'sprite_metadata.json') {
            try {
                const metadataResponse = await fetch(metadataPath);
                const metadata = await metadataResponse.json();
                
                frameWidth = metadata.frame_width;
                frameHeight = metadata.frame_height;
                totalFramesCount = metadata.frame_count;
                videoFPS = metadata.fps;
                
                const spriteImage = new Image();
                spriteImage.crossOrigin = 'anonymous';
                
                await new Promise((resolve, reject) => {
                    spriteImage.onload = () => {
                        spriteSheet = spriteImage;
                        
                        canvas.width = frameWidth;
                        canvas.height = frameHeight;
                        
                        canvas.style.top = `-${frameHeight / 2}px`;
                        
                        currentFrame = 0;
                        drawFrame(0, 0);
                        
                        if (firstCard) {
                            const cardTop = Math.round(firstCard.getBoundingClientRect().top);
                            targetFrame = calculateTargetFrame(cardTop);
                            currentFrame = targetFrame;
                            drawFrame(Math.floor(currentFrame), 0);
                        }
                        
                        resolve();
                    };
                    spriteImage.onerror = reject;
                    spriteImage.src = spritePath;
                });
            } catch (error) {
                // Ошибка при загрузке спрайта
            }
        }

        // Анимация - плавный переход к целевому кадру
        function animate(timestamp) {
            if (!isAnimating) {
                animationId = null;
                return;
            }
            
            if (!spriteSheet || totalFramesCount === 0) {
                animationId = null;
                return;
            }
            
            const now = performance.now();
            let deltaTime = 0;
            
            if (lastFrameTime > 0) {
                deltaTime = (now - lastFrameTime) / 1000;
                deltaTime = Math.min(deltaTime, 0.1);
            } else {
                lastFrameTime = now;
                deltaTime = 0.016;
            }
            
            const animationSpeedMultiplier = calculateAnimationSpeed(scrollSpeed);
            const transitionSpeed = videoFPS * animationSpeedMultiplier;
            const maxFrameChange = deltaTime * transitionSpeed;
            
            const diff = targetFrame - currentFrame;
            
            // Если скроллим вверх и достигли 28 кадра - запускаем смещение вниз (но продолжаем анимацию)
            if (!isScrollingDown && Math.floor(currentFrame) >= MAX_FRAME_DOWN && !isSlidingDown) {
                // Запускаем анимацию смещения кадров вниз, но не останавливаем основную анимацию
                startSlideDown();
            }
            
            // Если идет смещение вниз - продолжаем анимацию, но смещение обрабатывается отдельно
            // (смещение применяется в drawFrame через offsetY)
            
            if (Math.abs(diff) < 0.01) {
                currentFrame = targetFrame;
                isAnimating = false;
                // Применяем смещение, если идет анимация slide down
                const offsetToApply = isSlidingDown ? currentSlideOffset : 0;
                drawFrame(Math.floor(currentFrame), offsetToApply);
                animationId = null;
                return;
            }
            
            if (diff > 0) {
                currentFrame = Math.min(currentFrame + maxFrameChange, targetFrame);
            } else {
                currentFrame = Math.max(currentFrame - maxFrameChange, targetFrame);
            }
            
            const frameToDraw = Math.max(0, Math.min(Math.floor(currentFrame), totalFramesCount - 1));
            // Применяем смещение, если идет анимация slide down
            const offsetToApply = isSlidingDown ? currentSlideOffset : 0;
            drawFrame(frameToDraw, offsetToApply);
            
            lastFrameTime = now;
            animationId = requestAnimationFrame(animate);
        }

        // Вычисление целевого кадра на основе позиции карточки
        function calculateTargetFrame(cardTop) {
            // Используем стандартную логику для всех направлений скролла
            const distToFirst = Math.abs(cardTop - CARD_POSITION_FIRST_FRAME);
            const distToLast = Math.abs(cardTop - CARD_POSITION_LAST_FRAME);
            
            if (distToFirst <= distToLast) {
                return 0;
            } else {
                return totalFramesCount - 1;
            }
        }

        // Новая функция для вычисления целевого кадра при первоначальной позиции
        function calculateTargetFrameAtInitialPosition() {
            const currentFrameIndex = Math.floor(currentFrame);
            
            // Если анимация не на 1 кадре - проигрываем до первого кадра (кадр 0)
            if (currentFrameIndex > 0) {
                return 0; // Проигрывать до 1 кадра (кадр 0)
            }
            
            // Если уже на 1 кадре - возвращаем 0 (останавливаем)
            return 0;
        }

        // Обновление целевого кадра и запуск анимации
        function updateAnimation(cardTop) {
            if (!spriteSheet || totalFramesCount === 0) {
                return;
            }
            
            // Если идет смещение вниз - не обновляем анимацию кадров
            if (isSlidingDown) {
                return;
            }
            
            const INITIAL_CARD_POSITION = 88; // Первоначальное положение карточки
            
            // Проверяем, находится ли карточка в первоначальной позиции (88px и меньше)
            const isAtInitialPosition = cardTop <= INITIAL_CARD_POSITION;
            
            let newTargetFrame;
            
            if (isAtInitialPosition) {
                // Если карточка в первоначальной позиции - используем новую логику
                newTargetFrame = calculateTargetFrameAtInitialPosition();
            } else {
                // Иначе используем стандартную логику
                newTargetFrame = calculateTargetFrame(cardTop);
            }
            
            // Если целевой кадр изменился или анимация не запущена - обновляем и запускаем
            if (Math.abs(newTargetFrame - targetFrame) > 0.01 || !isAnimating) {
                targetFrame = newTargetFrame;
                
                if (!isAnimating) {
                    isAnimating = true;
                    lastFrameTime = 0;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    requestAnimationFrame(animate);
                }
            }
            
            // Если карточка в первоначальной позиции и достигли 1 кадра - останавливаем анимацию
            if (isAtInitialPosition && Math.abs(currentFrame - 0) < 0.01 && Math.abs(targetFrame - 0) < 0.01) {
                isAnimating = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }

        // Функция для вычисления множителя скорости анимации
        function calculateAnimationSpeed(scrollSpeedValue) {
            // Всегда возвращаем 3x скорость (увеличено на 1x)
            return 3;
        }

        // Текущее смещение для анимации slide down
        let currentSlideOffset = 0;

        // Запуск анимации смещения кадров вниз внутри canvas
        function startSlideDown() {
            if (isSlidingDown) return;
            
            isSlidingDown = true;
            slideStartTime = performance.now();
            currentSlideOffset = 0;
            
            // Анимация смещения будет применяться в drawFrame через currentSlideOffset
            // Обновляем смещение в отдельном цикле
            function updateSlideOffset() {
                if (!isSlidingDown) return;
                
                const now = performance.now();
                const elapsed = now - slideStartTime;
                const progress = Math.min(elapsed / SLIDE_DURATION, 1);
                
                // Линейное смещение без ускорения
                // Вычисляем смещение вниз (до самого низа canvas)
                const maxOffset = canvas.height; // Смещаем до самого низа canvas
                currentSlideOffset = maxOffset * progress;
                
                if (progress >= 1) {
                    // Анимация завершена
                    isSlidingDown = false;
                    currentSlideOffset = maxOffset;
                    return;
                }
                
                requestAnimationFrame(updateSlideOffset);
            }
            
            requestAnimationFrame(updateSlideOffset);
        }

        // Переменная для отслеживания предыдущей позиции скролла в updateDebugInfo
        let lastDebugScrollY = 0;

        // Обновление debug информации
        function updateDebugInfo() {
            const scrollY = scrollContainer.scrollTop;
            scrollYDebug.textContent = `scrollY: ${Math.round(scrollY)}px`;
            
            // Всегда показываем позицию первой карточки
            if (firstCard) {
                const firstCardTop = firstCard.getBoundingClientRect().top;
                cardTopDebug.textContent = `Card 1 top: ${Math.round(firstCardTop)}px`;
            }
            
            const emptySpaceHeight = emptySpace ? emptySpace.offsetHeight : window.innerHeight / 2;
            if (scrollY < emptySpaceHeight) {
                snapPointDebug.textContent = `Snap point: empty`;
            } else {
                snapPointDebug.textContent = `Snap point: normal`;
            }
            
            // Определяем направление скролла по изменению scrollY
            let scrollDirection = '-';
            if (scrollY > lastDebugScrollY) {
                scrollDirection = 'down';
            } else if (scrollY < lastDebugScrollY) {
                scrollDirection = 'up';
            }
            scrollDirectionDebug.textContent = `Scroll direction: ${scrollDirection}`;
            lastDebugScrollY = scrollY;
            
            // Текущий кадр анимации
            const currentFrameIndex = Math.floor(currentFrame);
            currentFrameDebug.textContent = `Current frame: ${currentFrameIndex}`;
            
            // Направление анимации
            let animationDirection = '-';
            if (isAnimating && totalFramesCount > 0) {
                if (currentFrame < targetFrame) {
                    animationDirection = 'forward';
                } else if (currentFrame > targetFrame) {
                    animationDirection = 'backward';
                } else {
                    animationDirection = 'stopped';
                }
            } else if (!isAnimating) {
                animationDirection = 'stopped';
            }
            animationDirectionDebug.textContent = `Animation direction: ${animationDirection}`;
        }

        // Обработчик скролла (как в scroll-animation.html)
        function setupScrollHandler() {
            scrollContainer.addEventListener('scroll', () => {
                if (!firstCard) return;
                
                const cardTop = firstCard.getBoundingClientRect().top;
                const currentScrollY = scrollContainer.scrollTop;
                const now = Date.now();
                
                // Определяем направление скролла
                isScrollingDown = currentScrollY > lastScrollY;
                
                // Вычисляем скорость скролла
                const timeDelta = (now - lastScrollTime) / 1000; // в секундах
                const scrollDelta = currentScrollY - lastScrollY;
                
                if (timeDelta > 0) {
                    scrollSpeed = Math.abs(scrollDelta / timeDelta); // пикселей в секунду
                } else {
                    scrollSpeed = 0;
                }
                
                lastScrollY = currentScrollY;
                lastScrollTime = now;
                
                // Управление snap для карточек
                const INITIAL_CARD_POSITION = 88; // Первоначальное положение карточки
                
                // Если позиция карточки 88px или меньше - отключаем snap для карточек
                if (cardTop <= INITIAL_CARD_POSITION) {
                    scrollContainer.classList.add('no-snap-cards');
                } else {
                    scrollContainer.classList.remove('no-snap-cards');
                }
                
                // Обновляем debug информацию сразу после определения направления
                updateDebugInfo();
                
                // Позиционирование background-section в зависимости от позиции карточки
                if (backgroundWrapper) {
                    const minCardPosition = 88; // Минимальная позиция карточки
                    const maxCardPosition = 493; // Максимальная позиция карточки
                    const minTranslateY = 0; // Когда карточка на максимальной позиции (493px) - background-section вверху
                    const maxTranslateY = 100; // Когда карточка на минимальной позиции (88px) - background-section внизу (100vh)
                    
                    let translateY;
                    if (cardTop <= minCardPosition) {
                        // Если карточка на 88px или меньше - background-section внизу
                        translateY = maxTranslateY;
                    } else if (cardTop >= maxCardPosition) {
                        // Если карточка на 493px или больше - background-section вверху
                        translateY = minTranslateY;
                    } else {
                        // Интерполяция между min и max в диапазоне 88px - 493px
                        const progress = (cardTop - minCardPosition) / (maxCardPosition - minCardPosition);
                        translateY = maxTranslateY - (maxTranslateY - minTranslateY) * progress;
                    }
                    
                    backgroundWrapper.style.transform = `translateY(${translateY}vh)`;
                }
                
                // Проверка: если карточка вернулась в первоначальное положение (88px и меньше), а анимация не запущена - принудительно запускаем
                // Проверяем, что карточка в исходном положении (88px и меньше)
                const isAtInitialPositionForAnim = cardTop <= INITIAL_CARD_POSITION;
                
                // Если карточка в исходном положении и анимация не активна или остановилась
                if (isAtInitialPositionForAnim && spriteSheet && totalFramesCount > 0) {
                    const currentFrameIndex = Math.floor(currentFrame);
                    
                    // Если анимация не на 1 кадре - проигрываем до первого кадра
                    if (currentFrameIndex > 0) {
                        const newTargetFrame = 0;
                        const needsUpdate = !isAnimating || Math.abs(targetFrame - newTargetFrame) > 0.01 || Math.abs(currentFrame - newTargetFrame) > 0.01;
                        
                        if (needsUpdate) {
                            targetFrame = newTargetFrame;
                            
                            if (!isAnimating) {
                                isAnimating = true;
                                lastFrameTime = 0;
                                if (animationId) {
                                    cancelAnimationFrame(animationId);
                                }
                                requestAnimationFrame(animate);
                            }
                        }
                    } else {
                        // Если уже на 1 кадре - останавливаем анимацию
                        if (isAnimating) {
                            isAnimating = false;
                            if (animationId) {
                                cancelAnimationFrame(animationId);
                                animationId = null;
                            }
                        }
                    }
                }
                
                // Обновляем анимацию на основе позиции карточки (как в scroll-animation.html)
                updateAnimation(cardTop);
            }, { passive: true });
        }

        // Инициализация фонового видео на canvas (общая функция)
        function initializeBackgroundVideoElement(video, canvas, ctx, isCentered = false) {
            if (!video || !canvas || !ctx) {
                return;
            }

            // Убеждаемся, что видео зациклено и без звука
            video.loop = true;
            video.muted = true;
            video.playsInline = true;

            let isPlaying = false;
            let animationFrameId = null;

            // Функция отрисовки кадра
            function drawVideoFrame() {
                if (video.readyState >= 2 && isPlaying) {
                    // Очищаем canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Рисуем текущий кадр видео
                    ctx.drawImage(video, 0, 0);
                    
                    // Получаем данные пикселей
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Обрабатываем пиксели для замены белого фона на прозрачность
                    const processedData = processFrameData(imageData);
                    
                    // Применяем обработанные данные обратно на canvas
                    ctx.putImageData(processedData, 0, 0);
                }
                
                // Продолжаем отрисовку только если видео играет
                if (isPlaying) {
                    animationFrameId = requestAnimationFrame(drawVideoFrame);
                }
            }

            // Методы для управления воспроизведением
            const cardData = {
                video: video,
                canvas: canvas,
                start: () => {
                    if (!isPlaying) {
                        isPlaying = true;
                        video.currentTime = 0;
                        const playPromise = video.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                video.addEventListener('loadeddata', () => {
                                    video.play().catch(() => {});
                                });
                            });
                        }
                        drawVideoFrame();
                    }
                },
                stop: () => {
                    if (isPlaying) {
                        isPlaying = false;
                        video.pause();
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                    }
                }
            };

            video.addEventListener('loadedmetadata', () => {
                // Устанавливаем размер canvas равным размеру видео
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            });

            return cardData;
        }

        // Массив для хранения данных о карточках
        const backgroundCards = [];

        // Определение центральной карточки
        function updateCenterCard() {
            if (!backgroundWrapper) return;

            const wrapperRect = backgroundWrapper.getBoundingClientRect();
            const wrapperCenter = wrapperRect.left + wrapperRect.width / 2;

            backgroundCards.forEach((cardData, index) => {
                const cardRect = cardData.canvas.getBoundingClientRect();
                const cardCenter = cardRect.left + cardRect.width / 2;
                const distance = Math.abs(cardCenter - wrapperCenter);
                const isCentered = distance < 50; // Порог для определения центра

                if (isCentered && !cardData.isCentered) {
                    // Карточка стала центральной
                    cardData.isCentered = true;
                    cardData.start();
                } else if (!isCentered && cardData.isCentered) {
                    // Карточка перестала быть центральной
                    cardData.isCentered = false;
                    cardData.stop();
                }
            });
        }

        // Обработчик скролла горизонтального контейнера
        function setupHorizontalScrollHandler() {
            if (!backgroundWrapper) return;

            backgroundWrapper.addEventListener('scroll', () => {
                updateCenterCard();
            }, { passive: true });
        }

        // Инициализация всех фоновых видео
        function initializeBackgroundVideo() {
            const leftCard = initializeBackgroundVideoElement(backgroundVideoLeft, backgroundCanvasLeft, backgroundCtxLeft);
            const centerCard = initializeBackgroundVideoElement(backgroundVideo, backgroundCanvas, backgroundCtx);
            const rightCard = initializeBackgroundVideoElement(backgroundVideoRight, backgroundCanvasRight, backgroundCtxRight);

            if (leftCard) {
                leftCard.isCentered = false;
                backgroundCards.push(leftCard);
            }
            if (centerCard) {
                centerCard.isCentered = true; // Центральная карточка по умолчанию
                backgroundCards.push(centerCard);
            }
            if (rightCard) {
                rightCard.isCentered = false;
                backgroundCards.push(rightCard);
            }

            // Запускаем анимацию для центральной карточки
            if (centerCard) {
                centerCard.start();
            }

            // Настраиваем обработчик горизонтального скролла
            setupHorizontalScrollHandler();

            // Первоначальная проверка центральной карточки
            setTimeout(() => {
                updateCenterCard();
            }, 100);
        }

        // Инициализация (как в scroll-animation.html)
        function initialize() {
            // Настраиваем обработчик скролла
            setupScrollHandler();
            
            // Инициализируем фоновое видео
            initializeBackgroundVideo();
            
            // Устанавливаем начальную позицию - нормальное состояние (минуя пустоту)
            requestAnimationFrame(() => {
                const emptySpaceHeight = emptySpace ? emptySpace.offsetHeight : window.innerHeight / 2;
                scrollContainer.scrollTop = emptySpaceHeight;
                
                // Устанавливаем начальный кадр на основе позиции карточки (как в scroll-animation.html)
                if (firstCard && spriteSheet) {
                    const cardTop = Math.round(firstCard.getBoundingClientRect().top);
                    targetFrame = calculateTargetFrame(cardTop);
                    currentFrame = targetFrame;
                    drawFrame(Math.floor(currentFrame), 0);
                }
                
                updateDebugInfo();
            });
            
            // Обновляем debug информацию периодически
            setInterval(updateDebugInfo, 100);
            
            // Загружаем спрайт
            loadSprite().catch(error => {
                // Ошибка при загрузке спрайта
            });
        }

        // Запускаем при загрузке
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
