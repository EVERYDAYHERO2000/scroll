<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Scroll Effect with CSS Scroll Snap</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background-color: #F2F2F2;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }

        /* Контейнер для скролла с snap */
        .scroll-container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        /* Snap точки */
        .snap-point {
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
        }

        /* Навигационное меню */
        .navigation {
            position: sticky;
            top: -56px;
            height: 56px;
            z-index: 100;
            width: 100%;
            background-color: #F2F2F2;
            border-radius: 16px 16px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }

        .navigation-phone {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .navigation-phone-number {
            font-size: 16px;
            font-weight: 500;
            color: #000;
        }

        .navigation-phone-dropdown {
            width: 12px;
            height: 12px;
            color: #666;
            cursor: pointer;
        }

        .navigation-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF6B9D, #9B59B6);
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .navigation-avatar-inner {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .navigation-avatar-icon {
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            position: relative;
        }

        .navigation-avatar-icon::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 50% 30%, #000 2px, transparent 2px),
                radial-gradient(circle at 50% 50%, #000 2px, transparent 2px),
                radial-gradient(circle at 50% 70%, #000 2px, transparent 2px);
            background-size: 100% 33.33%;
            background-repeat: no-repeat;
        }

        /* Пустота сверху - скрытая область */
        .empty-space {
            height: 50vh;
            display: flex;
            flex-direction: column;
            position: relative;
            transform: translateY(56px);
        }
        
        .empty-space-content {
            margin-top: auto;
            padding-bottom: 20px;
            text-align: center;
        }


        .layout-container {
            background-color: #F2F2F2;
            max-width: 370px;
            margin: 0 auto;
            width: 100%;
            padding: 0;
            position: relative;
        }

        @media (max-width: 400px) {
            .layout-container {
                padding: 0 16px;
            }
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            margin: 10px 0;
            position: relative;
            min-height: 370px;
        }


        .card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .card p {
            color: #666;
            line-height: 1.6;
        }

        #animationCanvas {
            position: absolute;
            left: 50%;
            transform: translateX(-50%) translateY(-14.5%) scale(0.4);
            top: 0;
            background: transparent;
            border: none;
            z-index: 10;
        }

        .card-container {
            position: relative;
            min-height: 300px;
            padding-top: 150px; /* Место для canvas */
        }

        .background-section {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0;
            display: flex;
            align-items: top;
            justify-content: center;
            overflow: hidden;
        }

        .background-section-wrapper {
            margin-top: 100px;
        }

        .background-section-wrapper.scale-animation {
            animation: scaleYAnimation .5s cubic-bezier(.45,-0.01,.55,1) forwards;
        }

        @keyframes scaleYAnimation {
            0% {
                transform: scaleY(1);
            }
            40% {
                transform: scaleY(1.05);
            }
            100% {
                transform: scaleY(1);
            }
        }

        .background-section img {
            width: 300px;
            height: 300px;
            object-fit: contain;
            object-position: center;
            transform: translateY(100vh);
            opacity: 0;
            /* Без transition, чтобы не было анимации при загрузке */
        }

        .background-section img.bounce-in {
            animation: bounceIn .5s cubic-bezier(.45,-0.01,.55,1) forwards;
        }

        @keyframes bounceIn {
            0% {
                transform: translateY(35vh);
                opacity: 1;
            }

            50% {
                transform: translateY(-10px);
                opacity: 1;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Контейнер для карточек с отступами */
        .cards-wrapper {
            padding-top: 0;
        }
        
        /* Убираем margin-top у первой карточки, так как отступ уже в snap-point */
        .layout-container > .card:first-of-type {
            margin-top: 0;
        }

        .debug-info {
            position: fixed;
            left: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

    </style>
</head>
<body>
    <div class="background-section">
        <div class="background-section-wrapper">
            <img src="image 227.png" alt="Background">
        </div>
    </div>
    
    <div class="scroll-container" id="scrollContainer">
        <!-- Пустота сверху - скрытая область, которая появляется при скролле вверх -->
        <div class="snap-point empty-space" id="emptySpace">
            <!-- Навигационное меню внутри empty-space -->
            <div class="navigation">
                <div class="navigation-phone">
                    <span class="navigation-phone-number">+7 (929) 747-78-70</span>
                    <svg class="navigation-phone-dropdown" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div class="navigation-avatar">
                    <div class="navigation-avatar-inner">
                        <div class="navigation-avatar-icon"></div>
                    </div>
                </div>
            </div>
            <div class="empty-space-content">
                
            </div>
        </div>
        
        <!-- Snap точка для нормального состояния - первая карточка на 32px + 56px (навигация) = 88px -->
        <div class="snap-point snap-point-normal" style="height: 88px;"></div>
        
        <!-- Контейнер с карточками -->
        <div class="cards-wrapper">
            <div class="layout-container">
                <div class="card" id="firstCard">
                    <div class="card-container">
                        <canvas id="animationCanvas"></canvas>
                    </div>
                    </div>

                <div class="card" id="secondCard">
                    </div>

                <div class="card">
                     </div>

                <div class="card">
                    </div>
            </div>
        </div>
        
        <!-- Snap точка для позиционирования второй карточки на 450px -->
        <div class="snap-point snap-point-second" style="height: calc(450px - 16px - 370px - 16px);"></div>
    </div>

    <div class="debug-info">
        <span id="scrollYDebug">scrollY: 0px</span>
        <span id="cardTopDebug">Card top: 0px</span>
        <span id="snapPointDebug">Snap point: -</span>
        <span id="scrollDirectionDebug">Direction: -</span>
        <span id="currentFrameDebug">Current frame: 0</span>
        <span id="animationDirectionDebug">Animation direction: -</span>
    </div>

    <script>
        const scrollContainer = document.getElementById('scrollContainer');
        const scrollYDebug = document.getElementById('scrollYDebug');
        const cardTopDebug = document.getElementById('cardTopDebug');
        const snapPointDebug = document.getElementById('snapPointDebug');
        const scrollDirectionDebug = document.getElementById('scrollDirectionDebug');
        const currentFrameDebug = document.getElementById('currentFrameDebug');
        const animationDirectionDebug = document.getElementById('animationDirectionDebug');
        const firstCard = document.getElementById('firstCard');
        const emptySpace = document.getElementById('emptySpace');
        const backgroundImage = document.querySelector('.background-section img');
        const backgroundWrapper = document.querySelector('.background-section-wrapper');
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        // Параметры спрайта
        let spriteSheet = null;
        let frameWidth = 0;
        let frameHeight = 0;
        let totalFramesCount = 0;
        let videoFPS = 30;

        // Позиции для управления анимацией (как в scroll-animation.html)
        const CARD_POSITION_FIRST_FRAME = 80;   // При этой позиции или меньше - первый кадр (0)
        const CARD_POSITION_LAST_FRAME = 200;  // При этой позиции или больше - последний кадр

        // Состояние анимации
        let currentFrame = 0;
        let targetFrame = 0;
        let isAnimating = false;
        let lastFrameTime = 0;
        let animationId = null;
        let lastScrollY = 0;
        let scrollSpeed = 0;
        let lastScrollTime = Date.now();
        let isScrollingDown = false;
        const MAX_FRAME_DOWN = 28; // Максимальный кадр при скролле вверх
        let isSlidingDown = false; // Флаг для анимации смещения вниз
        let slideStartTime = 0;
        const SLIDE_DURATION = 700; // 0.4 секунды для смещения вниз (быстрее)
        
        // Эффект time echo - история предыдущих кадров
        const echoHistory = [];
        const ECHO_DURATION = 0.5;
        const ECHO_FADE_STEPS = 5;

        // Цвета для прозрачности
        const transparentColors = [
            { r: 235, g: 233, b: 231 }, // #EBE9E7
            { r: 255, g: 255, b: 255 }  // #FFF
        ];
        const threshold = 50;

        // Функция для проверки, является ли цвет "прозрачным"
        function shouldBeTransparent(r, g, b) {
            return transparentColors.some(color => {
                return Math.abs(r - color.r) <= threshold &&
                       Math.abs(g - color.g) <= threshold &&
                       Math.abs(b - color.b) <= threshold;
            });
        }

        // Функция для обработки кадра и создания прозрачности
        function processFrameData(imageData) {
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                if (shouldBeTransparent(r, g, b)) {
                    data[i + 3] = 0; // alpha
                }
            }
            
            return imageData;
        }

        // Функция для получения обработанного изображения кадра
        function getProcessedFrameImage(frameIndex) {
            if (!spriteSheet || frameIndex < 0 || frameIndex >= totalFramesCount) {
                return null;
            }
            
            const sourceX = frameIndex * frameWidth;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = frameWidth;
            tempCanvas.height = frameHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(
                spriteSheet,
                sourceX, 0, frameWidth, frameHeight,
                0, 0, frameWidth, frameHeight
            );
            
            const imageData = tempCtx.getImageData(0, 0, frameWidth, frameHeight);
            return processFrameData(imageData);
        }

        // Функция для отрисовки кадра с эффектом time echo
        function drawFrame(frameIndex, offsetY = 0) {
            if (!spriteSheet) {
                return;
            }
            
            if (frameIndex < 0 || frameIndex >= totalFramesCount) {
                return;
            }
            
            const now = performance.now();
            
            // Очищаем canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Удаляем старые кадры из истории (старше ECHO_DURATION)
            const cutoffTime = now - (ECHO_DURATION * 1000);
            while (echoHistory.length > 0 && echoHistory[0].timestamp < cutoffTime) {
                echoHistory.shift();
            }
            
            // Отрисовываем предыдущие кадры с уменьшающейся прозрачностью (от старых к новым)
            // Применяем смещение напрямую к координатам, так как putImageData не учитывает трансформации
            for (let i = 0; i < echoHistory.length; i++) {
                const echo = echoHistory[i];
                const age = (now - echo.timestamp) / 1000;
                const fadeProgress = age / ECHO_DURATION;
                const alpha = 1 - fadeProgress;
                
                if (alpha > 0 && echo.imageData) {
                    const fadedData = new ImageData(
                        new Uint8ClampedArray(echo.imageData.data),
                        echo.imageData.width,
                        echo.imageData.height
                    );
                    
                    for (let j = 3; j < fadedData.data.length; j += 4) {
                        fadedData.data[j] = Math.floor(fadedData.data[j] * alpha);
                    }
                    
                    // Применяем смещение напрямую к координатам отрисовки
                    ctx.putImageData(fadedData, 0, offsetY);
                }
            }
            
            // Получаем текущий кадр
            const currentImageData = getProcessedFrameImage(frameIndex);
            if (currentImageData) {
                // Применяем смещение напрямую к координатам отрисовки
                ctx.putImageData(currentImageData, 0, offsetY);
                
                const imageDataCopy = new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                );
                echoHistory.push({
                    frameIndex: frameIndex,
                    timestamp: now,
                    imageData: imageDataCopy
                });
            }
            
            // Если идет смещение вниз - рисуем серый прямоугольник на переднем плане
            if (offsetY > 0) {
                ctx.fillStyle = '#ffffff'; // Серый цвет
                const rectX = 0; // От левого края
                const rectY = canvas.height / 2 + 31; // От середины canvas + 31px вниз (7 + 24)
                const rectWidth = canvas.width; // До правого края
                const rectHeight = canvas.height / 2 - 31; // До нижнего края (уменьшаем высоту на 31px)
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
            }
        }

        // Загрузка спрайта
        async function loadSprite(spritePath = 'sprite.png', metadataPath = 'sprite_metadata.json') {
            try {
                const metadataResponse = await fetch(metadataPath);
                const metadata = await metadataResponse.json();
                
                frameWidth = metadata.frame_width;
                frameHeight = metadata.frame_height;
                totalFramesCount = metadata.frame_count;
                videoFPS = metadata.fps;
                
                console.log('Метаданные загружены:', metadata);
                
                const spriteImage = new Image();
                spriteImage.crossOrigin = 'anonymous';
                
                await new Promise((resolve, reject) => {
                    spriteImage.onload = () => {
                        spriteSheet = spriteImage;
                        console.log('Спрайт-лист загружен:', spriteImage.width, 'x', spriteImage.height);
                        
                        canvas.width = frameWidth;
                        canvas.height = frameHeight;
                        
                        canvas.style.top = `-${frameHeight / 2}px`;
                        
                        currentFrame = 0;
                        drawFrame(0, 0);
                        
                        if (firstCard) {
                            const cardTop = Math.round(firstCard.getBoundingClientRect().top);
                            targetFrame = calculateTargetFrame(cardTop);
                            currentFrame = targetFrame;
                            drawFrame(Math.floor(currentFrame), 0);
                        }
                        
                        console.log('Спрайт готов к использованию');
                        resolve();
                    };
                    spriteImage.onerror = reject;
                    spriteImage.src = spritePath;
                });
            } catch (error) {
                console.error('Ошибка при загрузке спрайта:', error);
            }
        }

        // Анимация - плавный переход к целевому кадру
        function animate(timestamp) {
            if (!isAnimating) {
                animationId = null;
                return;
            }
            
            if (!spriteSheet || totalFramesCount === 0) {
                animationId = null;
                return;
            }
            
            const now = performance.now();
            let deltaTime = 0;
            
            if (lastFrameTime > 0) {
                deltaTime = (now - lastFrameTime) / 1000;
                deltaTime = Math.min(deltaTime, 0.1);
            } else {
                lastFrameTime = now;
                deltaTime = 0.016;
            }
            
            const animationSpeedMultiplier = calculateAnimationSpeed(scrollSpeed);
            const transitionSpeed = videoFPS * animationSpeedMultiplier;
            const maxFrameChange = deltaTime * transitionSpeed;
            
            const diff = targetFrame - currentFrame;
            
            // Если скроллим вверх и достигли 28 кадра - запускаем смещение вниз (но продолжаем анимацию)
            if (!isScrollingDown && Math.floor(currentFrame) >= MAX_FRAME_DOWN && !isSlidingDown) {
                console.log('Достигнут 28 кадр при скролле вверх, запускаем смещение');
                // Запускаем анимацию смещения кадров вниз, но не останавливаем основную анимацию
                startSlideDown();
            }
            
            // Если идет смещение вниз - продолжаем анимацию, но смещение обрабатывается отдельно
            // (смещение применяется в drawFrame через offsetY)
            
            if (Math.abs(diff) < 0.01) {
                currentFrame = targetFrame;
                isAnimating = false;
                // Применяем смещение, если идет анимация slide down
                const offsetToApply = isSlidingDown ? currentSlideOffset : 0;
                drawFrame(Math.floor(currentFrame), offsetToApply);
                animationId = null;
                return;
            }
            
            if (diff > 0) {
                currentFrame = Math.min(currentFrame + maxFrameChange, targetFrame);
            } else {
                currentFrame = Math.max(currentFrame - maxFrameChange, targetFrame);
            }
            
            const frameToDraw = Math.max(0, Math.min(Math.floor(currentFrame), totalFramesCount - 1));
            // Применяем смещение, если идет анимация slide down
            const offsetToApply = isSlidingDown ? currentSlideOffset : 0;
            drawFrame(frameToDraw, offsetToApply);
            
            lastFrameTime = now;
            animationId = requestAnimationFrame(animate);
        }

        // Вычисление целевого кадра на основе позиции карточки
        function calculateTargetFrame(cardTop) {
            // Используем стандартную логику для всех направлений скролла
            const distToFirst = Math.abs(cardTop - CARD_POSITION_FIRST_FRAME);
            const distToLast = Math.abs(cardTop - CARD_POSITION_LAST_FRAME);
            
            if (distToFirst <= distToLast) {
                return 0;
            } else {
                return totalFramesCount - 1;
            }
        }

        // Обновление целевого кадра и запуск анимации
        function updateAnimation(cardTop) {
            if (!spriteSheet || totalFramesCount === 0) {
                return;
            }
            
            // Если идет смещение вниз - не обновляем анимацию кадров
            if (isSlidingDown) {
                return;
            }
            
            const newTargetFrame = calculateTargetFrame(cardTop);
            
            // Если целевой кадр изменился или анимация не запущена - обновляем и запускаем
            if (Math.abs(newTargetFrame - targetFrame) > 0.01 || !isAnimating) {
                targetFrame = newTargetFrame;
                
                if (!isAnimating) {
                    isAnimating = true;
                    lastFrameTime = 0;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    requestAnimationFrame(animate);
                }
            }
        }

        // Функция для вычисления множителя скорости анимации
        function calculateAnimationSpeed(scrollSpeedValue) {
            // Всегда возвращаем 3x скорость (увеличено на 1x)
            return 3;
        }

        // Текущее смещение для анимации slide down
        let currentSlideOffset = 0;

        // Запуск анимации смещения кадров вниз внутри canvas
        function startSlideDown() {
            if (isSlidingDown) return;
            
            console.log('Запуск смещения кадров вниз');
            isSlidingDown = true;
            slideStartTime = performance.now();
            currentSlideOffset = 0;
            
            // Анимация смещения будет применяться в drawFrame через currentSlideOffset
            // Обновляем смещение в отдельном цикле
            function updateSlideOffset() {
                if (!isSlidingDown) return;
                
                const now = performance.now();
                const elapsed = now - slideStartTime;
                const progress = Math.min(elapsed / SLIDE_DURATION, 1);
                
                // Линейное смещение без ускорения
                // Вычисляем смещение вниз (до самого низа canvas)
                const maxOffset = canvas.height; // Смещаем до самого низа canvas
                currentSlideOffset = maxOffset * progress;
                
                if (progress >= 1) {
                    // Анимация завершена
                    console.log('Смещение завершено');
                    isSlidingDown = false;
                    currentSlideOffset = maxOffset;
                    return;
                }
                
                requestAnimationFrame(updateSlideOffset);
            }
            
            requestAnimationFrame(updateSlideOffset);
        }

        // Обновление debug информации
        function updateDebugInfo() {
            const scrollY = scrollContainer.scrollTop;
            scrollYDebug.textContent = `scrollY: ${Math.round(scrollY)}px`;
            
            const emptySpaceHeight = emptySpace ? emptySpace.offsetHeight : window.innerHeight / 2;
            
            if (scrollY < emptySpaceHeight) {
                cardTopDebug.textContent = `Empty space visible: ${Math.round(scrollY)}px`;
                snapPointDebug.textContent = `Snap point: empty`;
            } else if (firstCard) {
                const firstCardTop = firstCard.getBoundingClientRect().top;
                cardTopDebug.textContent = `Card 1 top: ${Math.round(firstCardTop)}px`;
                snapPointDebug.textContent = `Snap point: normal`;
            }
            
            const scrollDirection = scrollY > lastScrollY ? 'down' : 'up';
            scrollDirectionDebug.textContent = `Direction: ${scrollDirection}`;
            lastScrollY = scrollY;
            
            // Текущий кадр анимации
            const currentFrameIndex = Math.floor(currentFrame);
            currentFrameDebug.textContent = `Current frame: ${currentFrameIndex}`;
            
            // Направление анимации
            let animationDirection = '-';
            if (isAnimating && totalFramesCount > 0) {
                if (currentFrame < targetFrame) {
                    animationDirection = 'forward';
                } else if (currentFrame > targetFrame) {
                    animationDirection = 'backward';
                } else {
                    animationDirection = 'stopped';
                }
            } else if (!isAnimating) {
                animationDirection = 'stopped';
            }
            animationDirectionDebug.textContent = `Animation direction: ${animationDirection}`;
        }

        // Обработчик скролла (как в scroll-animation.html)
        function setupScrollHandler() {
            scrollContainer.addEventListener('scroll', () => {
                if (!firstCard) return;
                
                const cardTop = firstCard.getBoundingClientRect().top;
                const currentScrollY = scrollContainer.scrollTop;
                const now = Date.now();
                
                // Определяем направление скролла
                isScrollingDown = currentScrollY > lastScrollY;
                
                // Вычисляем скорость скролла
                const timeDelta = (now - lastScrollTime) / 1000; // в секундах
                const scrollDelta = currentScrollY - lastScrollY;
                
                if (timeDelta > 0) {
                    scrollSpeed = Math.abs(scrollDelta / timeDelta); // пикселей в секунду
                } else {
                    scrollSpeed = 0;
                }
                
                lastScrollY = currentScrollY;
                lastScrollTime = now;
                
                // Анимация фонового изображения
                if (backgroundImage && backgroundWrapper) {
                    const currentFrameIndex = Math.floor(currentFrame);
                    const INITIAL_CARD_POSITION = 88; // Первоначальное положение карточки (32px + 56px навигация)
                    const POSITION_TOLERANCE = 5; // Допустимое отклонение
                    const isAtInitialPosition = Math.abs(cardTop - INITIAL_CARD_POSITION) <= POSITION_TOLERANCE;
                    
                    // Условие 1: Сбрасываем анимацию когда карточка в первоначальном положении
                    if (isAtInitialPosition) {
                        // Убираем класс bounce-in
                        if (backgroundImage.classList.contains('bounce-in')) {
                            backgroundImage.classList.remove('bounce-in');
                            // Сбрасываем стили анимации
                            backgroundImage.style.animation = 'none';
                            setTimeout(() => {
                                backgroundImage.style.animation = '';
                            }, 10);
                        }
                        // Убираем класс scale-animation
                        if (backgroundWrapper.classList.contains('scale-animation')) {
                            backgroundWrapper.classList.remove('scale-animation');
                            // Сбрасываем стили анимации
                            backgroundWrapper.style.animation = 'none';
                            setTimeout(() => {
                                backgroundWrapper.style.animation = '';
                            }, 10);
                        }
                    } else {
                        // Условие 2: Запускаем анимацию когда кадр >= 28 И скроллим вверх (только если карточка НЕ в первоначальном положении)
                        if (currentFrameIndex >= 28 && !isScrollingDown) {
                            if (!backgroundImage.classList.contains('bounce-in')) {
                                backgroundImage.classList.add('bounce-in');
                            }
                            if (!backgroundWrapper.classList.contains('scale-animation')) {
                                backgroundWrapper.classList.add('scale-animation');
                            }
                        }
                    }
                }
                
                // Проверка: если карточка вернулась в первоначальное положение (88px), а анимация не запущена - принудительно запускаем
                const INITIAL_CARD_POSITION = 88; // Первоначальное положение карточки (32px + 56px навигация)
                const POSITION_TOLERANCE = 5; // Допустимое отклонение в пикселях
                
                // Проверяем, что карточка в исходном положении
                const isAtInitialPosition = Math.abs(cardTop - INITIAL_CARD_POSITION) <= POSITION_TOLERANCE;
                
                // Если карточка в исходном положении и анимация не активна или остановилась
                if (isAtInitialPosition && spriteSheet && totalFramesCount > 0) {
                    const newTargetFrame = calculateTargetFrame(cardTop);
                    
                    // Всегда обновляем целевой кадр и запускаем анимацию, если она не активна
                    // Также запускаем если целевой кадр отличается от текущего
                    const needsUpdate = !isAnimating || Math.abs(targetFrame - newTargetFrame) > 0.01 || Math.abs(currentFrame - newTargetFrame) > 0.01;
                    
                    if (needsUpdate) {
                        targetFrame = newTargetFrame;
                        
                        if (!isAnimating) {
                            isAnimating = true;
                            lastFrameTime = 0;
                            if (animationId) {
                                cancelAnimationFrame(animationId);
                            }
                            requestAnimationFrame(animate);
                        }
                    }
                }
                
                // Обновляем debug информацию
                updateDebugInfo();
                
                // Обновляем анимацию на основе позиции карточки (как в scroll-animation.html)
                updateAnimation(cardTop);
            }, { passive: true });
        }

        // Инициализация (как в scroll-animation.html)
        function initialize() {
            // Настраиваем обработчик скролла
            setupScrollHandler();
            
            // Устанавливаем начальную позицию - нормальное состояние (минуя пустоту)
            requestAnimationFrame(() => {
                const emptySpaceHeight = emptySpace ? emptySpace.offsetHeight : window.innerHeight / 2;
                scrollContainer.scrollTop = emptySpaceHeight;
                
                // Устанавливаем начальный кадр на основе позиции карточки (как в scroll-animation.html)
                if (firstCard && spriteSheet) {
                    const cardTop = Math.round(firstCard.getBoundingClientRect().top);
                    targetFrame = calculateTargetFrame(cardTop);
                    currentFrame = targetFrame;
                    drawFrame(Math.floor(currentFrame), 0);
                }
                
                updateDebugInfo();
            });
            
            // Обновляем debug информацию периодически
            setInterval(updateDebugInfo, 100);
            
            // Загружаем спрайт
            console.log('Загрузка спрайта...');
            loadSprite().catch(error => {
                console.error('Ошибка при загрузке спрайта:', error);
            });
        }

        // Запускаем при загрузке
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
